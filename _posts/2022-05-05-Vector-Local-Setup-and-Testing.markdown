---
layout: default
title:  "Vector Local Setup and Testing"
date:   2022-05-05 00:58:43 +0530
categories: jekyll update
---

**Summary**
- Ran Vector locally as a docker container with a file source and file sink
- Produced random logs using chentex/random-logger image and wrote them to a input log file using a background process
- Read the input log using file source, and parsed it using `regex_parser` and wrote it to an output log using in json
- Learnt about various configurable options in the `vector.toml` file and different types of sources, sinks and transforms.

Doing a local setup where we run a container to produce random logs continuously and then writing them to a `input.log` file. We will run vector in a docker container, the `input.log` file will act as a source for vector. Vector will read from the source and write to a sink. The sink will be of file type only, output logs from vector will be written to `output.log` file.

**Objective** - To understand the setup process of vector and the syntax and configuration of the `vector.toml` file.

The image being used for producing logs - `chentex/random-logger` - [Dockerhub](https://hub.docker.com/r/chentex/random-logger)

Running the container to produce logs after a random interval of time between 100 to 400 milliseconds.
{% highlight shell %}
docker run -d chentex/random-logger:latest 100 400
{% endhighlight %}

Creating the `input.log` file which will update continuously and have all the logs generated by the container.
{% highlight shell %}
docker logs -f <container-name> &> ./input/input.log &
{% endhighlight %}

- `-f `(i.e.`--follow`): writes all existing logs and follows logging everything that comes next.
- `&>` redirects both the standard output and standard error.
- `&` runs it in background

In the below vector configuration we use the file source and file sink and the [regex_parser](https://assume-role-docs--vector-project.netlify.app/docs/reference/transforms/regex_parser/) transform. We use named capturing groups in the regex expression to capture different fields from the logs into different groups which could be easily referred to later. These logs go to file sink and are written as json using the `ndjson` codec.

{% highlight shell %}
# vector.toml

# Set global options

# data_dir
# he directory used for persisting Vector state, such as on-disk buffers,
# file checkpoints, and more. Please make sure the Vector project has write
# permissions to this directory.
data_dir = "/var/lib/vector"

# Vector's API (disabled by default)
# Enabling to see metrics of Vector instance and information about the Vector topology through a beautiful dashboard-style interface
[api]
enabled = true
# address = "127.0.0.1:8686"

# Ingest data by tailing one or more files
[sources.input_log_file]
type         = "file"
include      = ["/var/log/test/input.log"]    # supports globbing


# Structure and parse via Vector's Remap Language
[transforms.parse_log]
inputs = ["input_log_file"]
type   = "regex_parser"
regex = "^(?P<timestamp>[\\w\\-:\\+]+) (?P<level>\\w+) (?P<message>.*)$"
drop_field = false # default - true
field = "message" # the entire log is message field only

[sinks.output_log_file]
type = "file"
inputs = [ "parse_log" ]
compression = "none"
path = "/tmp/output.log"

  [sinks.output_log_file.encoding]
  codec = "ndjson"

{% endhighlight %}

[Vector top](https://vector.dev/highlights/2020-12-23-vector-top/)

Below is how the workspace directory looks like

![Directory structure of workspace](/assets/images/2022-05-05/1.png)

Here is how the docker compose file looks like

{% highlight shell %}
# docker-compose.yml
services:
  log-generator:
    image: chentex/random-logger:latest
    command: 100 400

  vector:
    image: timberio/vector:0.21.1-alpine
    ports:
      - "8686:8686"
    volumes:
      - ./vector.toml:/etc/vector/vector.toml:ro
      - ./input:/var/log/input
      - ./output:/var/log/output
{% endhighlight %}

After starting the containers using `docker-compose -d` , run the backgound process to write logs to `./input/input.log`.

The output logs coming from vector will be present under `./output/output.log` and look like below

{% highlight shell %}
{"file":"/var/log/input/input.log","host":"e361bfbe6685","level":"INFO","message":"This is less important than debug log and is often used to provide context in the current task.","source_type":"file","timestamp":"2022-05-05T23:46:32+0000"}
{"file":"/var/log/input/input.log","host":"e361bfbe6685","level":"INFO","message":"This is less important than debug log and is often used to provide context in the current task.","source_type":"file","timestamp":"2022-05-05T23:46:32+0000"}
{"file":"/var/log/input/input.log","host":"e361bfbe6685","level":"DEBUG","message":"This is a debug log that shows a log that can be ignored.","source_type":"file","timestamp":"2022-05-05T23:46:33+0000"}
{"file":"/var/log/input/input.log","host":"e361bfbe6685","level":"WARN","message":"A warning that should be ignored is usually at this level and should be actionable.","source_type":"file","timestamp":"2022-05-05T23:46:33+0000"}
{"file":"/var/log/input/input.log","host":"e361bfbe6685","level":"WARN","message":"A warning that should be ignored is usually at this level and should be actionable.","source_type":"file","timestamp":"2022-05-05T23:46:33+0000"}
{"file":"/var/log/input/input.log","host":"e361bfbe6685","level":"DEBUG","message":"This is a debug log that shows a log that can be ignored.","source_type":"file","timestamp":"2022-05-05T23:46:34+0000"}
{% endhighlight %}

## Misc Learnings

### A Quick Revision of Regular Expressions

Case sensitivity, global matching catch be enabled or disabled. If global matching (`//g`) is disabled it will find all the matches in the string otherwise only the first match.
All regular Expressions start and end with `\`.

- `/cloud/` - looks for the exact string cloud, similar to normal search
- `/c+/` - match c or more than one c, ex - c, cc, ccc, ccccc
- `/c+l?/`- match c or more than one c, optionally with one l after it, ex - c, cc, cl, cccccl
- `/cl*/` - match one c and zero or more l, ex - c, cl, cll, clllll
- `/.lo*/` - match anything except new line then one l and zero or more o, ex - alo, clo. clooo. tl. gl
- `/\.lo/` - match the exact period, not the wildcard `\` is escape sequence, ex - .lo
- `/\w/` - capture all words - example - cloud, software etc.
- `/\W/` - matches anything that is not a word
- `/\s/` - matches all the whitespaces
- `/\S/` - matches anything that is not a whitespace
- `/\w{4}/` - matches all words that are 4 characters in length
- `/\w{4,}/` - matches all words that are 4 characters or more in length
- `/\w{4,8}/` - matches all words that are between 4 to 8 characters long
- `/[cl]o/` - match where first character is either c or l and one o after it - co, lo
- `/[a-z]l/` - match where first character is any character between a to z and second character is l, ex - al. bl. cl. dl. el etc
- `/[a-zA-Z]l/` - match where first character is any character between a to z or A to Z and second character is l, ex - al. bl. cl. Al. Bl etc
- `/(c|l|o){2.3}\./` - `()` is character grouping, other matchers like length matches can we applied to these groups as a whole, so this expression match either character c, l or o with length between 2 and 3 and a period after that. ex - cl. , clo. , ccc. , coo. , loc. , lc. , cl.
- `/^C/` - match the first character of line if it is C, to check for at every line instead of just the beginning of string turn multi-line on.
- `/\.$/` - match period at the end of line (if multiline is enabled else end of the entire string).
- `/(?<=Cl)./` - positive look behind - Match any character before which Cl comes but not match Cl itself, ex - if string is "Cloud" then match will be o
- `/(?<!Cl)./` - negative look behind - match every character that does not have Cl before it
- `/.(?=lo)/` - look ahead - match every character that has lo after it, ex - if string is "Cloud" then match will be C
- `/.(?!lo)/` - match evert character that is not followed by lo

**Example**

Let's try to write regex for capturing phone numbers.
1234567890 - `/\d{10}/`
123-456-7890 - `/\d{3}-?\d{3}-?\d{4}/`
123 456 7890 - `/\d{3}[ -]?\d{3}[ -]?\d{4}/`
123 456 7890 - `/(\d{3})[ -]?(\d{3})[ -]?(\d{4})/` - capture groups - $1$2$3 - 1234567890

For named catures - add `?<group-name>` to the start of the capture group

The logs produced by `chentex/random-logger` look like below

{% highlight shell %}
2022-05-05T21:51:39+0000 WARN A warning that should be ignored is usually at this level and should be actionable.
2022-05-05T21:51:38+0000 ERROR An error is usually an exception that has been caught and not handled.
2022-05-05T21:51:38+0000 WARN A warning that should be ignored is usually at this level and should be actionable.
2022-05-05T21:51:39+0000 WARN A warning that should be ignored is usually at this level and should be actionable.
2022-05-05T21:51:39+0000 DEBUG This is a debug log that shows a log that can be ignored.
2022-05-05T21:51:39+0000 INFO This is less important than debug log and is often used to provide context in the current task.
{% endhighlight %}

So the regular expression with named captures to capture this will be

{% highlight shell %}
(?<time>\S+) (?<level>[A-Z]+) (?<message>.*)
{% endhighlight %}
The `time` capture group captures any consecutive non whitespace characters until a white space is encountered, then the `level` capture group captures any consecutive characters in the range A-Z until a white space character is encountered, then the `message` capture group captures anything after that.

A useful tool to test and debug regex - [regex101](https://regex101.com/)
